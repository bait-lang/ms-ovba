// SPDX-FileCopyrightText: 2024-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0

package msovba

import encoding.binary
import math

struct CopyTokenHelp {
mut:
	adjusted_bits u16
	length_mask u16
	offset_mask u16
	max_length u16
}

fun copytoken_helper(pos i32, start i32) CopyTokenHelp{
	diff := pos - start
	bits := math.ceil(math.log2(diff as f64))

	mut ct := CopyTokenHelp{
		adjusted_bits = math.max(bits, 4 as f64) as u16
	}

	ct.length_mask = 0xFFFF >> ct.adjusted_bits
	ct.offset_mask = ~ct.length_mask
	ct.max_length = (0xFFFF >> ct.adjusted_bits) + 3
	return ct
}

pub fun decompress(compressed []u8) ![]u8 {
	mut plain := []u8

	if compressed[0] != 0x01 {
		return error('invalid stream signature ${compressed[0]}')
	}

	mut pos := 1

	for pos < compressed.length {
		header := binary.u16_le_at(compressed, pos)

		sig := (header >> 12) & 0x07
		if sig != 0b011 {
			return error('invalid chunk signature ${sig}')
		}

		size := (header & 0x0FFF) + 3
		flag := (header >> 15) & 0x01
		if flag == 0 and size != 4098 {
			return error('chunk size != 4098')
		}
		if flag == 1 and size > 4098 {
			return error('chunk size > 4098')
		}

		end := math.min(compressed.length, pos + (size as i32))
		pos += 2

		if flag == 0 {
			plain.push_many(compressed.slice(pos, pos + 4096))
			pos += 4096
		} else {
			plain_start := plain.length
			for pos < end {
				flag_byte := compressed[pos]
				pos += 1

				for bit_idx := 0; bit_idx < 8; bit_idx += 1 {
					if pos >= end {
						break
					}

					flag_bit := (flag_byte >> (bit_idx as u8)) & 0x1
					if flag_bit == 0 {
						plain.push(compressed[pos])
						pos += 1
					} else {
						token := binary.u16_le_at(compressed, pos)
						ct_help := copytoken_helper(plain.length, plain_start)
						length := (token & ct_help.length_mask) + 3
						t1 := token & ct_help.offset_mask
						t2 := 16 as u16 - ct_help.adjusted_bits
						offset := (t1 >> t2) + 1
						copy_start := plain.length - (offset as i32)
						for i := copy_start; i < copy_start + (length as i32); i += 1 {
							plain.push(plain[i])
						}
						pos += 2
					}
				}
			}
		}

		break
	}

	return plain
}
