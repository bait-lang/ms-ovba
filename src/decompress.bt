// SPDX-FileCopyrightText: 2024-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package msovba

import encoding.binary
import math

pub fun decompress(compressed []u8) ![]u8 {
	mut s := State {
		compressed = compressed
		pos = 1
	}

	if s.compressed[0] != 0x01 {
		return error('invalid stream signature ${s.compressed[0]}')
	}

	for s.pos < s.compressed.length {
		header := binary.u16_le_at(s.compressed, s.pos)

		sig := (header >> 12) & 0x07
		if sig != 0b011 {
			return error('invalid chunk signature ${sig}')
		}

		size := (header & 0x0FFF) + 3
		flag := (header >> 15) & 0x01
		if flag == 0 and size != 4098 {
			return error('chunk size != 4098')
		}
		if flag == 1 and size > 4098 {
			return error('chunk size > 4098')
		}

		end := math.min(s.compressed.length, s.pos + (size as i32))
		s.pos += 2

		if flag == 0 {
			s.plain.push_many(s.compressed.slice(s.pos, s.pos + 4096))
			s.pos += 4096
		} else {
			plain_start := s.plain.length
			for s.pos < end {
				flag_byte := s.compressed[s.pos]
				s.pos += 1

				for bit_idx := 0; bit_idx < 8; bit_idx += 1 {
					if s.pos >= end {
						break
					}

					flag_bit := (flag_byte >> (bit_idx as u8)) & 0x1
					if flag_bit == 0 {
						s.plain.push(s.compressed[s.pos])
						s.pos += 1
					} else {
						token := binary.u16_le_at(s.compressed, s.pos)
						ct_help := copytoken_help(s.plain.length, plain_start)
						length := (token & ct_help.length_mask) + 3
						t1 := token & ct_help.offset_mask
						t2 := 16 as u16 - ct_help.bit_count
						offset := (t1 >> t2) + 1
						copy_start := s.plain.length - (offset as i32)
						for i := copy_start; i < copy_start + (length as i32); i += 1 {
							s.plain.push(s.plain[i])
						}
						s.pos += 2
					}
				}
			}
		}

		break
	}

	return s.plain
}
